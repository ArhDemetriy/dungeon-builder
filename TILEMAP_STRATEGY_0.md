# Стратегия оптимизации TilemapController

## Контекст

Текущая реализация бесконечной генерации карты в `src/game/scenes/TilemapController.ts` и `src/game/scenes/MainScene.ts` опирается на таймер (`tilemapStreamingTimer`), который вызывает обновление слоя.
**Проблемы текущего подхода:**

1. **Рассинхронизация**: Таймер не знает о состоянии камеры (движется/стоит) и фазах рендеринга.
2. **Сложное движение**: Трудно предсказать поведение при резкой смене направления (например, влево -> вверх), так как таймер просто срабатывает по времени.
3. **Отсутствие Idle-состояния**: Нет механизма, гарантирующего, что когда камера остановится, под ней будет сгенерирован идеальный центр слоя.
4. **Производительность**: Постоянные проверки по таймеру или каждый кадр могут быть избыточны.

## Предлагаемое решение: Spatial Culling + Target State

Мы отказываемся от таймеров в пользу проверки состояния в `update()` с использованием "Безопасной зоны" (Safe Zone).

### 1. Концепция "Безопасной Зоны" (Spatial Culling)

Вместо того чтобы спрашивать "пора ли обновляться?" каждый кадр или по таймеру, мы определяем прямоугольник внутри текущего активного слоя — `Safe Zone` (например, центральные 40% слоя).

- **Если центр камеры внутри Safe Zone**: Мы гарантированно ничего не делаем. Проверка `rect.contains(x, y)` крайне дешевая (~0.001ms).
- **Если центр камеры вышел за пределы**: Это триггер к вычислению новой позиции слоя.

### 2. Паттерн "Target State" (Отложенная цель)

Мы разделяем "желание обновиться" и "процесс обновления".

- **TargetLayerPos**: Координаты, где слой _должен_ быть, исходя из позиции камеры.
- **CurrentLayerPos**: Координаты, где слой находится _сейчас_.
- **Worker (Async)**: Процесс, который приводит `Current` к `Target`.

**Преимущества:**

- Если игрок быстро меняет направление (влево -> вверх), мы просто обновляем `TargetLayerPos`. "Воркер" подхватит последнюю актуальную цель, как только освободится.
- Исключается конкуренция между "движением" и "остановкой".

### 3. Детекция покоя (Idle State)

Для точного центрирования слоя после остановки камеры используется простой таймер простоя внутри `update`.

- Сравниваем позицию камеры с предыдущим кадром.
- Если `delta == 0` в течение N мс (напр. 500мс) -> устанавливаем `TargetLayerPos` идеально по центру камеры.

## Детальный алгоритм (Pseudocode)

### TilemapController.update(time, delta)

Этот метод вызывается каждый кадр из `MainScene`.

```typescript
update(time, delta) {
    // 1. Проверка движения
    const isMoving = camera.pos !== lastCameraPos;

    if (isMoving) {
        resetIdleTimer();

        // БЫСТРАЯ ПРОВЕРКА (Fast Path)
        if (safeRegion.contains(camera.x, camera.y)) {
            return; // Максимальная экономия ресурсов
        }

        // Камера вышла за пределы -> Считаем новую цель
        // Сдвигаем слой в сторону движения
        targetLayerPos = calculateOffsetPosition(camera);
    } else {
        // Камера стоит
        incrementIdleTimer();
        if (idleTimer > IDLE_THRESHOLD) {
            // Идеальная центровка
            targetLayerPos = calculateCenteredPosition(camera);
        }
    }

    // 2. Попытка выполнения (Throttle / Async Guard)
    tryProcessUpdate();
}
```

### tryProcessUpdate()

Отвечает за фактическую перегенерацию.

```typescript
async tryProcessUpdate() {
    if (isUpdating) return; // Воркер занят
    if (currentPos === targetPos) return; // Уже на месте

    isUpdating = true;
    const jobTarget = { ...targetLayerPos }; // Фиксируем цель

    try {
        // Тяжелая операция генерации
        await generateAndSwitchLayer(jobTarget);

        currentPos = jobTarget;
        updateSafeRegion(jobTarget); // !Важно: обновляем Safe Zone под новый слой
    } finally {
        isUpdating = false;
    }
}
```

## План внедрения

### Шаг 1: Модификация `src/game/scenes/TilemapController.ts`

1. Добавить свойства:
   - `private safeRegion: Phaser.Geom.Rectangle`
   - `private isUpdating: boolean`
   - `private targetLayerPos: {x, y}`
   - `private currentLayerPos: {x, y}`
   - `private idleTimer: number`
2. Реализовать метод `update(time, delta)`.
3. Реализовать метод `tryProcessUpdate()`.
4. Добавить метод `updateSafeRegion(x, y)` (вызывать после перемещения слоя).
5. Убрать старый метод `reloadLayerOnCameraShift` или переписать его логику внутри `tryProcessUpdate`.

### Шаг 2: Модификация `src/game/scenes/MainScene.ts`

1. Удалить `tilemapStreamingTimer`.
2. В методе `update()` добавить вызов `this.tilemapController.update(time, delta)`.

## Плюсы и минусы

### Плюсы

- **Производительность**: Внутри "комфортной зоны" нагрузка на CPU близка к нулю.
- **Плавность**: Генерация происходит только по необходимости, а не по таймеру.
- **Предсказуемость**: Логика четко разделена на фазы "анализ" и "выполнение".
- **Устойчивость**: "Target State" проглатывает хаотичные движения игрока, всегда стремясь к последнему валидному состоянию.

### Минусы

- Чуть сложнее в отладке, чем простой `setInterval`.
- Требует тщательной настройки размеров `Safe Zone` (зависит от скорости камеры и размера тайлмапа), чтобы избежать "мерцания" границ при быстром движении.
