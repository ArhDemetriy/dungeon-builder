# Обзор стратегий оптимизации TilemapController

В данном документе проведен сравнительный анализ трех предложенных стратегий управления бесконечным тайлмапом (`TILEMAP_STRATEGY_0.md`, `_1.md`, `_2.md`).

## Сравнительная таблица

| Характеристика            | Strategy 0 (Spatial)                     | Strategy 1 (Vector + Queue)            | Strategy 2 (Velocity + Priority)          |
| :------------------------ | :--------------------------------------- | :------------------------------------- | :---------------------------------------- |
| **Триггер обновления**    | Выход за пределы статической "Safe Zone" | Интервальная проверка (100мс) + Вектор | Каждый кадр + Предиктивная позиция        |
| **Детекция движения**     | Позиционная (Delta Pos)                  | Мгновенный вектор + сглаживание        | EMA (Экспоненциальное скользящее среднее) |
| **Управление состоянием** | Target State (Целевое состояние)         | Mutex + Очередь намерений (Size 1)     | Priority Queue (Movement > Center)        |
| **Idle/Центровка**        | Таймер простоя                           | Таймер `setTimeout`                    | Скорость < Threshold + Debounce           |
| **Сложность**             | Низкая                                   | Средняя                                | Высокая                                   |
| **Риски**                 | "Туннелирование" при высокой скорости    | Лаг реакции из-за интервала 100мс      | Сложность отладки очереди                 |

---

## Детальный разбор

### Strategy 0: Spatial Culling + Target State

**Суть:** Использование статической геометрической зоны. Если камера внутри прямоугольника — ничего не делаем.

- **✅ Сильные стороны:**
  - **Архитектура "Target State"**: Разделение на "где я хочу быть" (`Target`) и "где я есть" (`Current`) — это самый надежный паттерн для асинхронных систем. Он автоматически решает проблему Race Conditions (воркер просто стремится к актуальному Target).
  - **Производительность**: Проверка `Rect.contains()` невероятно быстрая.
- **❌ Слабые стороны:**
  - **Отсутствие предсказания**: При быстром движении камера может вылететь за пределы слоя быстрее, чем он сгенерируется.
  - **Статичность**: "Безопасная зона" не меняется в зависимости от скорости или направления.

### Strategy 1: Vector Motion + Intent Queue

**Суть:** Опрос позиции каждые 100мс, вычисление вектора, "агрессивные" границы в сторону движения.

- **✅ Сильные стороны:**
  - **Адаптивные границы**: Идея расширять границу проверки (Lookahead) в сторону движения — отличная.
- **❌ Слабые стороны:**
  - **Интервальная проверка (Polling)**: Проверка раз в 100мс рассинхронизирована с `update()` цикла игры. Это может вызвать визуальные рывки или задержку реакции на ввод игрока.
  - **Mutex (Блокировки)**: Ручное управление флагами блокировки (`isCreating`) сложнее поддерживать, чем реактивный паттерн "Target State".

### Strategy 2: Velocity-Based Predictive Layer Management

**Суть:** Сглаживание скорости (EMA), предсказание позиции через 300мс, очередь с приоритетами.

- **✅ Сильные стороны:**
  - **Математика движения**: Использование EMA (`velocity * 0.7 + new * 0.3`) дает самое плавное и точное определение остановки.
  - **Предсказание**: Расчет `PredictedPos = Current + Velocity * Time` позволяет начать генерацию _до_ того, как игрок подойдет к краю.
  - **Debounce**: Грамотная защита от "дребезга" при центровке.
- **❌ Слабые стороны:**
  - **Overengineering очереди**: Система с типами операций (`'movement' | 'center'`) и очередями может быть избыточной. Паттерн "Target State" из Стратегии 0 решает ту же проблему проще (последняя цель всегда побеждает).

---

## Синтез (Выводы для финальной стратегии)

Для идеального решения необходимо объединить:

1. **Математику движения из Стратегии 2**: EMA для сглаживания скорости и точной детекции `Idle`.
2. **Архитектуру из Стратегии 0**: Паттерн `TargetLayerPos` + Асинхронный цикл (`Loop`). Это заменит сложные очереди и мьютексы. Если `Target` изменился, воркер просто подхватит его на следующей итерации.
3. **Логику предсказания из Стратегий 1 и 2**: Использовать не текущую позицию камеры, а _предсказанную_ (`PredictedPos`) для проверки вхождения в границы слоя.
4. **Пространственную оптимизацию из Стратегии 0**: Если предсказанная позиция всё еще глубоко внутри текущего слоя — выходим рано (Fast Return).

**Результат**: Гибридная стратегия "Predictive Target State".
