# Стратегия управления обновлением слоев тайлмапы (Tilemap Layer Update Strategy)

## Контекст проблемы

### Текущая ситуация

В проекте dungeon-builder используется система динамической загрузки тайлмапы с двумя слоями (double buffering). Создание нового слоя является дорогой операцией (100-300мс), что требует оптимизации стратегии обновления.

**Текущая реализация:**

- Используется таймер, который периодически вызывает `reloadLayerOnCameraShift()` (см. `src/game/scenes/MainScene.ts:47-58`)
- Проверка позиции камеры происходит через `checkCameraPosition()` (см. `src/game/scenes/TilemapController.ts:115-137`)
- Слой создается, когда камера находится во внешней трети текущего слоя
- Используется система двойной буферизации с двумя слоями (`layer0` и `layer1`)

### Выявленные проблемы

1. **Определение остановки камеры**: Нет эффективного способа определить, что камера остановилась, без постоянных проверок, нагружающих рендер
2. **Параллельное создание слоев**: При остановке камеры может запуститься `centerLayerOnCamera()` параллельно с созданием слоя от движения камеры, что приводит к конфликтам
3. **Сложное движение камеры**: При изменении направления движения (например, движение влево до границы, затем вверх) система не может корректно определить реальное направление движения, так как проверяется только текущая позиция, а не вектор движения

### Пример проблемного сценария

Игрок двигает камеру справа до левой внешней трети слоя, затем не выходит за пределы и начинает двигаться вверх. В этом случае:

- По таймеру регулярно будут сигналы о намерении выйти за левую границу
- Затем сигналы о движении к левой верхней границе
- Никогда не наступит событие о движении вверх
- Камера может остановиться, но `centerLayerOnCamera()` не будет вызван из-за постоянных сигналов о границах

## Предложенная стратегия: Velocity-Based Predictive Layer Management

### Общая концепция

Стратегия основана на отслеживании **вектора скорости камеры** и **предсказании направления движения**, что позволяет:

- Определять остановку камеры без дополнительных проверок в рендере
- Предотвращать параллельное создание слоев через систему очередей с приоритетами
- Корректно обрабатывать сложное движение камеры через предсказание траектории

### Ключевые компоненты

#### 1. Отслеживание скорости камеры (Velocity Tracking)

**Принцип работы:**

- В каждом кадре (`update()`) вычисляется изменение позиции камеры
- Используется экспоненциальное скользящее среднее (EMA) для сглаживания скорости
- Скорость хранится в пикселях на миллисекунду (px/ms)

**Формула сглаживания:**

```
velocity_new = velocity_old * smoothing_factor + velocity_instant * (1 - smoothing_factor)
```

**Параметры:**

- `VELOCITY_SMOOTHING = 0.7` - коэффициент сглаживания (чем больше, тем плавнее)
- `STOP_THRESHOLD = 0.5` - порог скорости для определения остановки (px/ms)

**Преимущества:**

- Минимальная нагрузка на рендер (простое вычисление в `update()`)
- Устойчивость к микро-дрожанию камеры
- Точное определение остановки

#### 2. Предсказание направления движения (Direction Prediction)

**Принцип работы:**

- На основе текущей скорости предсказывается позиция камеры через заданное время
- Проверяется, будет ли предсказанная позиция в зоне, требующей создания нового слоя
- Используется время предсказания `VELOCITY_PREDICTION_TIME = 300ms`

**Алгоритм:**

1. Если камера остановлена (`isCameraStopped()`), возвращается `null`
2. Вычисляется предсказанная позиция: `predicted_pos = current_pos + velocity * prediction_time`
3. Проверяется, находится ли предсказанная позиция во внешней трети слоя
4. Возвращается направление сдвига `{x: -1|0|1, y: -1|0|1}` или `null`

**Преимущества:**

- Корректно обрабатывает сложное движение (смена направления)
- Предотвращает ложные срабатывания при движении вдоль границы
- Учитывает реальную траекторию движения, а не только текущую позицию

#### 3. Система очередей с приоритетами (Priority Queue System)

**Принцип работы:**

- Используется флаг `isLayerGenerationInProgress` для отслеживания активной операции
- Очередь операций с типами: `'movement'` (приоритет выше) или `'center'` (приоритет ниже)
- Операции выполняются последовательно, новые запросы ставятся в очередь

**Правила приоритетов:**

1. Операция `'movement'` имеет приоритет над `'center'`
2. Если идет генерация слоя, новые запросы `'center'` игнорируются, если в очереди есть `'movement'`
3. Новый запрос `'movement'` отменяет ожидающее `'center'` и ставится в очередь
4. После завершения операции проверяется очередь и выполняется следующая операция

**Преимущества:**

- Гарантирует отсутствие параллельного выполнения операций
- Приоритет движения обеспечивает плавность при активном движении
- Центрирование выполняется только когда камера действительно остановилась

#### 4. Debounce для центрирования (Center Layer Debounce)

**Принцип работы:**

- При остановке камеры запускается таймер с задержкой `CENTER_DEBOUNCE_DELAY = 800ms`
- Если камера начинает двигаться до истечения таймера, он отменяется
- После истечения таймера проверяется, что камера все еще остановлена, и запускается `centerLayerOnCamera()`

**Преимущества:**

- Предотвращает ненужные центрирования при кратковременных остановках
- Обеспечивает центрирование только после реальной остановки
- Легко отменяется при возобновлении движения

## Детальная структура реализации

### Новые свойства в TilemapController

```typescript
// Флаги управления
private isLayerGenerationInProgress = false;
private pendingOperation: 'movement' | 'center' | null = null;

// Отслеживание скорости
private cameraVelocity = { x: 0, y: 0 };
private lastCameraPosition = { x: 0, y: 0 };
private lastVelocityUpdateTime = 0;

// Debounce для центрирования
private centerLayerDebounceTimer?: number;

// Константы
private readonly VELOCITY_SMOOTHING = 0.7;
private readonly STOP_THRESHOLD = 0.5; // px/ms
private readonly CENTER_DEBOUNCE_DELAY = 800; // ms
private readonly VELOCITY_PREDICTION_TIME = 300; // ms
```

### Новые методы в TilemapController

#### `updateCameraVelocity()`

- Вызывается в каждом кадре из `MainScene.update()`
- Вычисляет мгновенную скорость на основе изменения позиции
- Применяет сглаживание через EMA
- Обновляет `lastCameraPosition` и `lastVelocityUpdateTime`

#### `isCameraStopped(): boolean`

- Вычисляет модуль скорости: `sqrt(velocity.x² + velocity.y²)`
- Возвращает `true`, если скорость меньше `STOP_THRESHOLD`

#### `predictCameraDirection(): {x, y} | null`

- Проверяет остановку камеры
- Вычисляет предсказанную позицию через `VELOCITY_PREDICTION_TIME`
- Проверяет предсказанную позицию на нахождение во внешней трети слоя
- Возвращает направление сдвига или `null`

#### `requestLayerUpdate(type: 'movement' | 'center'): Promise<void>`

- Проверяет приоритеты и текущее состояние
- Если операция уже выполняется, ставит в очередь или отменяет
- Вызывает `executeLayerUpdate()` если возможно

#### `executeLayerUpdate(type: 'movement' | 'center'): Promise<void>`

- Устанавливает флаг `isLayerGenerationInProgress`
- Выполняет соответствующую операцию (`centerLayerOnCamera()` или `reloadLayerOnCameraShift()`)
- Обновляет среднее время генерации
- Проверяет очередь и выполняет следующую операцию

#### `scheduleCenterLayerOnStop()`

- Отменяет существующий таймер центрирования
- Устанавливает новый таймер с задержкой `CENTER_DEBOUNCE_DELAY`
- По истечении таймера проверяет остановку и вызывает `requestLayerUpdate('center')`

#### `cancelCenterLayerDebounce()`

- Отменяет таймер центрирования, если он установлен

### Модификация существующих методов

#### `reloadLayerOnCameraShift()` → `async reloadLayerOnCameraShift()`

- Использует `predictCameraDirection()` вместо `checkCameraPosition()`
- Если предсказание возвращает `null`, планирует центрирование через `scheduleCenterLayerOnStop()`
- Использует предсказанное направление для определения смещения слоя

### Изменения в MainScene

#### `create()`

- Инициализация позиции камеры в `TilemapController` (в конструкторе)

#### `update(time, delta)`

- Вызов `tilemapController.updateCameraVelocity()` в начале метода
- Остальная логика без изменений

#### `tilemapStreamingTimer` callback

- Вызов `updateCameraVelocity()` перед проверкой
- Использование `predictCameraDirection()` для определения необходимости обновления
- Вызов `requestLayerUpdate('movement')` при движении к границе
- Вызов `scheduleCenterLayerOnStop()` при остановке

## Плюсы стратегии

1. **Эффективное определение остановки**: Использование скорости вместо постоянных проверок позиции снижает нагрузку на рендер
2. **Предотвращение конфликтов**: Система очередей гарантирует последовательное выполнение операций
3. **Корректная обработка сложного движения**: Предсказание направления учитывает реальную траекторию движения
4. **Приоритизация операций**: Движение имеет приоритет над центрированием, обеспечивая плавность
5. **Оптимизация центрирования**: Debounce предотвращает ненужные центрирования при кратковременных остановках
6. **Расширяемость**: Легко добавить новые типы операций или изменить приоритеты
7. **Асинхронная готовность**: Архитектура готова к асинхронным операциям создания слоев

## Минусы и ограничения

1. **Дополнительная память**: Хранение скорости и позиции требует небольшого дополнительного расхода памяти
2. **Вычислительная нагрузка**: Вычисление скорости в каждом кадре (минимальная, но присутствует)
3. **Задержка предсказания**: Предсказание может быть неточным при резких изменениях направления
4. **Настройка параметров**: Требует тюнинга констант (`VELOCITY_SMOOTHING`, `STOP_THRESHOLD`, `VELOCITY_PREDICTION_TIME`, `CENTER_DEBOUNCE_DELAY`)
5. **Сложность отладки**: Больше состояний и переходов между ними усложняет отладку
6. **Зависимость от частоты кадров**: Скорость вычисляется на основе `deltaTime`, что может влиять на точность при нестабильном FPS

## Предложения по улучшению и правкам

### 1. Вынос констант в конфигурацию

**Файл:** `src/game/constants.ts`

Добавить секцию конфигурации для управления слоями:

```typescript
export const TILEMAP_LAYER_CONFIG = {
  velocitySmoothing: 0.7,
  stopThreshold: 0.5, // px/ms
  centerDebounceDelay: 800, // ms
  velocityPredictionTime: 300, // ms
} as const;
```

**Преимущества:**

- Легко настраивать параметры без изменения кода
- Можно сделать настраиваемым через UI для тестирования
- Централизованное управление константами

### 2. Добавление метрик для отладки

**В TilemapController добавить:**

```typescript
private debugMetrics = {
  lastVelocity: { x: 0, y: 0 },
  lastPrediction: { x: 0, y: 0 } | null,
  queueLength: 0,
  operationsCount: { movement: 0, center: 0 },
};
```

**Метод для получения метрик:**

```typescript
getDebugMetrics() {
  return {
    ...this.debugMetrics,
    isGenerating: this.isLayerGenerationInProgress,
    pendingOp: this.pendingOperation,
  };
}
```

**Преимущества:**

- Упрощает отладку и профилирование
- Позволяет визуализировать работу системы
- Помогает в настройке параметров

### 3. Оптимизация: пропуск обновлений при отсутствии движения

**В `reloadLayerOnCameraShift()`:**

```typescript
async reloadLayerOnCameraShift() {
  // Если камера остановлена и нет предсказанного движения, не создаем слой
  if (this.isCameraStopped()) {
    const predictedShift = this.predictCameraDirection();
    if (!predictedShift) {
      this.scheduleCenterLayerOnStop();
      return;
    }
  }

  // ... остальная логика
}
```

**Преимущества:**

- Экономит ресурсы при остановке камеры
- Предотвращает ненужные проверки

### 4. Обработка edge cases

**Добавить проверки:**

- Проверка на `NaN` или `Infinity` в скорости
- Ограничение максимальной скорости для предотвращения артефактов
- Проверка на валидность позиции камеры перед вычислением скорости

```typescript
updateCameraVelocity() {
  const now = performance.now();
  const { centerX, centerY } = this.scene.cameras.main;

  // Валидация позиции
  if (!isFinite(centerX) || !isFinite(centerY)) return;

  const deltaTime = now - this.lastVelocityUpdateTime;
  if (deltaTime < 1 || deltaTime > 1000) return; // Защита от аномалий

  // ... остальная логика

  // Ограничение максимальной скорости
  const maxSpeed = 10; // px/ms
  this.cameraVelocity.x = Math.max(-maxSpeed, Math.min(maxSpeed, this.cameraVelocity.x));
  this.cameraVelocity.y = Math.max(-maxSpeed, Math.min(maxSpeed, this.cameraVelocity.y));
}
```

### 5. Асинхронная оптимизация (для будущего)

**Подготовка к асинхронным операциям:**

```typescript
private async executeLayerUpdate(type: 'movement' | 'center'): Promise<void> {
  if (this.isLayerGenerationInProgress) return;

  this.isLayerGenerationInProgress = true;
  const startTime = performance.now();

  try {
    if (type === 'center') {
      await this.centerLayerOnCameraAsync();
    } else {
      await this.reloadLayerOnCameraShiftAsync();
    }

    this.setAvgTileGenTime(performance.now() - startTime);
  } catch (error) {
    console.error('Layer generation failed:', error);
    // Обработка ошибок
  } finally {
    this.isLayerGenerationInProgress = false;

    // Проверяем очередь
    if (this.pendingOperation) {
      const nextOp = this.pendingOperation;
      this.pendingOperation = null;
      await this.executeLayerUpdate(nextOp);
    }
  }
}
```

**Преимущества:**

- Готовность к асинхронным операциям (Web Workers, chunked loading)
- Корректная обработка ошибок
- Не блокирует основной поток

### 6. Улучшение предсказания для диагонального движения

**В `predictCameraDirection()`:**

```typescript
private predictCameraDirection(): { x: -1 | 0 | 1; y: -1 | 0 | 1 } | null {
  if (this.isCameraStopped()) return null;

  // Нормализация скорости для более точного предсказания
  const speed = Math.sqrt(this.cameraVelocity.x ** 2 + this.cameraVelocity.y ** 2);
  if (speed < this.STOP_THRESHOLD) return null;

  // Используем нормализованное направление для предсказания
  const directionX = this.cameraVelocity.x / speed;
  const directionY = this.cameraVelocity.y / speed;

  // Предсказываем позицию с учетом направления
  const predictionDistance = speed * this.VELOCITY_PREDICTION_TIME;
  const predictedX = this.lastCameraPosition.x + directionX * predictionDistance;
  const predictedY = this.lastCameraPosition.y + directionY * predictionDistance;

  // ... остальная логика проверки
}
```

**Преимущества:**

- Более точное предсказание при диагональном движении
- Учитывает реальную скорость, а не только направление

## Структура файлов

### Основные файлы для модификации

1. **`src/game/scenes/TilemapController.ts`**
   - Добавление свойств для отслеживания скорости
   - Реализация методов `updateCameraVelocity()`, `predictCameraDirection()`, `requestLayerUpdate()`, `executeLayerUpdate()`, `scheduleCenterLayerOnStop()`
   - Модификация `reloadLayerOnCameraShift()` для использования предсказания

2. **`src/game/scenes/MainScene.ts`**
   - Вызов `updateCameraVelocity()` в `update()`
   - Модификация callback таймера для использования новой системы

3. **`src/game/constants.ts`** (опционально)
   - Добавление `TILEMAP_LAYER_CONFIG` для констант

### Зависимости

- `performance.now()` - для измерения времени
- `window.setTimeout()` / `window.clearTimeout()` - для debounce таймера
- Существующие методы `centerLayerOnCamera()`, `checkCameraPosition()`, `updateLayer()`

## Последовательность внедрения

1. **Этап 1: Базовая инфраструктура**
   - Добавить свойства для отслеживания скорости
   - Реализовать `updateCameraVelocity()` и `isCameraStopped()`
   - Интегрировать вызов в `MainScene.update()`

2. **Этап 2: Предсказание направления**
   - Реализовать `predictCameraDirection()`
   - Модифицировать `reloadLayerOnCameraShift()` для использования предсказания

3. **Этап 3: Система очередей**
   - Реализовать `requestLayerUpdate()` и `executeLayerUpdate()`
   - Добавить флаги управления состоянием

4. **Этап 4: Debounce центрирования**
   - Реализовать `scheduleCenterLayerOnStop()` и `cancelCenterLayerDebounce()`
   - Интегрировать в логику таймера

5. **Этап 5: Тестирование и настройка**
   - Тестирование различных сценариев движения
   - Настройка констант для оптимальной работы
   - Добавление метрик для отладки (опционально)

## Тестовые сценарии

### Сценарий 1: Простое движение к границе

- Камера движется вправо к правой границе слоя
- **Ожидаемое поведение**: Создается новый слой справа до достижения границы

### Сценарий 2: Остановка камеры

- Камера движется, затем останавливается
- **Ожидаемое поведение**: Через 800ms создается слой, центрированный на камере

### Сценарий 3: Смена направления

- Камера движется влево до левой трети, затем вверх
- **Ожидаемое поведение**: Система корректно определяет движение вверх и создает слой сверху

### Сценарий 4: Движение вдоль границы

- Камера движется вдоль границы слоя, не выходя за пределы
- **Ожидаемое поведение**: Не создаются ненужные слои, только при реальном приближении к выходу

### Сценарий 5: Резкое изменение направления

- Камера резко меняет направление движения
- **Ожидаемое поведение**: Предсказание адаптируется через сглаживание скорости

### Сценарий 6: Параллельные запросы

- Во время создания слоя от движения камера останавливается
- **Ожидаемое поведение**: Запрос на центрирование ставится в очередь и выполняется после завершения

## Заключение

Предложенная стратегия решает все выявленные проблемы:

- ✅ Эффективное определение остановки камеры
- ✅ Предотвращение параллельного создания слоев
- ✅ Корректная обработка сложного движения камеры

Стратегия готова к внедрению и может быть расширена для поддержки асинхронных операций в будущем. Все компоненты спроектированы с учетом производительности и расширяемости.
